{
  "version": 3,
  "sources": ["../../leaflet-polylinedecorator/dist/leaflet.polylineDecorator.js"],
  "sourcesContent": ["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(require('leaflet')) :\n\ttypeof define === 'function' && define.amd ? define(['leaflet'], factory) :\n\t(factory(global.L));\n}(this, (function (L$1) { 'use strict';\n\nL$1 = L$1 && L$1.hasOwnProperty('default') ? L$1['default'] : L$1;\n\n// functional re-impl of L.Point.distanceTo,\n// with no dependency on Leaflet for easier testing\nfunction pointDistance(ptA, ptB) {\n    var x = ptB.x - ptA.x;\n    var y = ptB.y - ptA.y;\n    return Math.sqrt(x * x + y * y);\n}\n\nvar computeSegmentHeading = function computeSegmentHeading(a, b) {\n    return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI + 90 + 360) % 360;\n};\n\nvar asRatioToPathLength = function asRatioToPathLength(_ref, totalPathLength) {\n    var value = _ref.value,\n        isInPixels = _ref.isInPixels;\n    return isInPixels ? value / totalPathLength : value;\n};\n\nfunction parseRelativeOrAbsoluteValue(value) {\n    if (typeof value === 'string' && value.indexOf('%') !== -1) {\n        return {\n            value: parseFloat(value) / 100,\n            isInPixels: false\n        };\n    }\n    var parsedValue = value ? parseFloat(value) : 0;\n    return {\n        value: parsedValue,\n        isInPixels: parsedValue > 0\n    };\n}\n\nvar pointsEqual = function pointsEqual(a, b) {\n    return a.x === b.x && a.y === b.y;\n};\n\nfunction pointsToSegments(pts) {\n    return pts.reduce(function (segments, b, idx, points) {\n        // this test skips same adjacent points\n        if (idx > 0 && !pointsEqual(b, points[idx - 1])) {\n            var a = points[idx - 1];\n            var distA = segments.length > 0 ? segments[segments.length - 1].distB : 0;\n            var distAB = pointDistance(a, b);\n            segments.push({\n                a: a,\n                b: b,\n                distA: distA,\n                distB: distA + distAB,\n                heading: computeSegmentHeading(a, b)\n            });\n        }\n        return segments;\n    }, []);\n}\n\nfunction projectPatternOnPointPath(pts, pattern) {\n    // 1. split the path into segment infos\n    var segments = pointsToSegments(pts);\n    var nbSegments = segments.length;\n    if (nbSegments === 0) {\n        return [];\n    }\n\n    var totalPathLength = segments[nbSegments - 1].distB;\n\n    var offset = asRatioToPathLength(pattern.offset, totalPathLength);\n    var endOffset = asRatioToPathLength(pattern.endOffset, totalPathLength);\n    var repeat = asRatioToPathLength(pattern.repeat, totalPathLength);\n\n    var repeatIntervalPixels = totalPathLength * repeat;\n    var startOffsetPixels = offset > 0 ? totalPathLength * offset : 0;\n    var endOffsetPixels = endOffset > 0 ? totalPathLength * endOffset : 0;\n\n    // 2. generate the positions of the pattern as offsets from the path start\n    var positionOffsets = [];\n    var positionOffset = startOffsetPixels;\n    do {\n        positionOffsets.push(positionOffset);\n        positionOffset += repeatIntervalPixels;\n    } while (repeatIntervalPixels > 0 && positionOffset < totalPathLength - endOffsetPixels);\n\n    // 3. projects offsets to segments\n    var segmentIndex = 0;\n    var segment = segments[0];\n    return positionOffsets.map(function (positionOffset) {\n        // find the segment matching the offset,\n        // starting from the previous one as offsets are ordered\n        while (positionOffset > segment.distB && segmentIndex < nbSegments - 1) {\n            segmentIndex++;\n            segment = segments[segmentIndex];\n        }\n\n        var segmentRatio = (positionOffset - segment.distA) / (segment.distB - segment.distA);\n        return {\n            pt: interpolateBetweenPoints(segment.a, segment.b, segmentRatio),\n            heading: segment.heading\n        };\n    });\n}\n\n/**\n* Finds the point which lies on the segment defined by points A and B,\n* at the given ratio of the distance from A to B, by linear interpolation.\n*/\nfunction interpolateBetweenPoints(ptA, ptB, ratio) {\n    if (ptB.x !== ptA.x) {\n        return {\n            x: ptA.x + ratio * (ptB.x - ptA.x),\n            y: ptA.y + ratio * (ptB.y - ptA.y)\n        };\n    }\n    // special case where points lie on the same vertical axis\n    return {\n        x: ptA.x,\n        y: ptA.y + (ptB.y - ptA.y) * ratio\n    };\n}\n\n(function() {\r\n    // save these original methods before they are overwritten\r\n    var proto_initIcon = L.Marker.prototype._initIcon;\r\n    var proto_setPos = L.Marker.prototype._setPos;\r\n\r\n    var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');\r\n\r\n    L.Marker.addInitHook(function () {\r\n        var iconOptions = this.options.icon && this.options.icon.options;\r\n        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;\r\n        if (iconAnchor) {\r\n            iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');\r\n        }\r\n        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom' ;\r\n        this.options.rotationAngle = this.options.rotationAngle || 0;\r\n\r\n        // Ensure marker keeps rotated during dragging\r\n        this.on('drag', function(e) { e.target._applyRotation(); });\r\n    });\r\n\r\n    L.Marker.include({\r\n        _initIcon: function() {\r\n            proto_initIcon.call(this);\r\n        },\r\n\r\n        _setPos: function (pos) {\r\n            proto_setPos.call(this, pos);\r\n            this._applyRotation();\r\n        },\r\n\r\n        _applyRotation: function () {\r\n            if(this.options.rotationAngle) {\r\n                this._icon.style[L.DomUtil.TRANSFORM+'Origin'] = this.options.rotationOrigin;\r\n\r\n                if(oldIE) {\r\n                    // for IE 9, use the 2D rotation\r\n                    this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';\r\n                } else {\r\n                    // for modern browsers, prefer the 3D accelerated version\r\n                    this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';\r\n                }\r\n            }\r\n        },\r\n\r\n        setRotationAngle: function(angle) {\r\n            this.options.rotationAngle = angle;\r\n            this.update();\r\n            return this;\r\n        },\r\n\r\n        setRotationOrigin: function(origin) {\r\n            this.options.rotationOrigin = origin;\r\n            this.update();\r\n            return this;\r\n        }\r\n    });\r\n})();\n\nL$1.Symbol = L$1.Symbol || {};\n\n/**\n* A simple dash symbol, drawn as a Polyline.\n* Can also be used for dots, if 'pixelSize' option is given the 0 value.\n*/\nL$1.Symbol.Dash = L$1.Class.extend({\n    options: {\n        pixelSize: 10,\n        pathOptions: {}\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.pathOptions.clickable = false;\n    },\n\n    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {\n        var opts = this.options;\n        var d2r = Math.PI / 180;\n\n        // for a dot, nothing more to compute\n        if (opts.pixelSize <= 1) {\n            return L$1.polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);\n        }\n\n        var midPoint = map.project(dirPoint.latLng);\n        var angle = -(dirPoint.heading - 90) * d2r;\n        var a = L$1.point(midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2, midPoint.y + opts.pixelSize * Math.sin(angle) / 2);\n        // compute second point by central symmetry to avoid unecessary cos/sin\n        var b = midPoint.add(midPoint.subtract(a));\n        return L$1.polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);\n    }\n});\n\nL$1.Symbol.dash = function (options) {\n    return new L$1.Symbol.Dash(options);\n};\n\nL$1.Symbol.ArrowHead = L$1.Class.extend({\n    options: {\n        polygon: true,\n        pixelSize: 10,\n        headAngle: 60,\n        pathOptions: {\n            stroke: false,\n            weight: 2\n        }\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.pathOptions.clickable = false;\n    },\n\n    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {\n        return this.options.polygon ? L$1.polygon(this._buildArrowPath(dirPoint, map), this.options.pathOptions) : L$1.polyline(this._buildArrowPath(dirPoint, map), this.options.pathOptions);\n    },\n\n    _buildArrowPath: function _buildArrowPath(dirPoint, map) {\n        var d2r = Math.PI / 180;\n        var tipPoint = map.project(dirPoint.latLng);\n        var direction = -(dirPoint.heading - 90) * d2r;\n        var radianArrowAngle = this.options.headAngle / 2 * d2r;\n\n        var headAngle1 = direction + radianArrowAngle;\n        var headAngle2 = direction - radianArrowAngle;\n        var arrowHead1 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle1), tipPoint.y + this.options.pixelSize * Math.sin(headAngle1));\n        var arrowHead2 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle2), tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));\n\n        return [map.unproject(arrowHead1), dirPoint.latLng, map.unproject(arrowHead2)];\n    }\n});\n\nL$1.Symbol.arrowHead = function (options) {\n    return new L$1.Symbol.ArrowHead(options);\n};\n\nL$1.Symbol.Marker = L$1.Class.extend({\n    options: {\n        markerOptions: {},\n        rotate: false\n    },\n\n    initialize: function initialize(options) {\n        L$1.Util.setOptions(this, options);\n        this.options.markerOptions.clickable = false;\n        this.options.markerOptions.draggable = false;\n    },\n\n    buildSymbol: function buildSymbol(directionPoint, latLngs, map, index, total) {\n        if (this.options.rotate) {\n            this.options.markerOptions.rotationAngle = directionPoint.heading + (this.options.angleCorrection || 0);\n        }\n        return L$1.marker(directionPoint.latLng, this.options.markerOptions);\n    }\n});\n\nL$1.Symbol.marker = function (options) {\n    return new L$1.Symbol.Marker(options);\n};\n\nvar isCoord = function isCoord(c) {\n    return c instanceof L$1.LatLng || Array.isArray(c) && c.length === 2 && typeof c[0] === 'number';\n};\n\nvar isCoordArray = function isCoordArray(ll) {\n    return Array.isArray(ll) && isCoord(ll[0]);\n};\n\nL$1.PolylineDecorator = L$1.FeatureGroup.extend({\n    options: {\n        patterns: []\n    },\n\n    initialize: function initialize(paths, options) {\n        L$1.FeatureGroup.prototype.initialize.call(this);\n        L$1.Util.setOptions(this, options);\n        this._map = null;\n        this._paths = this._initPaths(paths);\n        this._bounds = this._initBounds();\n        this._patterns = this._initPatterns(this.options.patterns);\n    },\n\n    /**\n    * Deals with all the different cases. input can be one of these types:\n    * array of LatLng, array of 2-number arrays, Polyline, Polygon,\n    * array of one of the previous.\n    */\n    _initPaths: function _initPaths(input, isPolygon) {\n        var _this = this;\n\n        if (isCoordArray(input)) {\n            // Leaflet Polygons don't need the first point to be repeated, but we do\n            var coords = isPolygon ? input.concat([input[0]]) : input;\n            return [coords];\n        }\n        if (input instanceof L$1.Polyline) {\n            // we need some recursivity to support multi-poly*\n            return this._initPaths(input.getLatLngs(), input instanceof L$1.Polygon);\n        }\n        if (Array.isArray(input)) {\n            // flatten everything, we just need coordinate lists to apply patterns\n            return input.reduce(function (flatArray, p) {\n                return flatArray.concat(_this._initPaths(p, isPolygon));\n            }, []);\n        }\n        return [];\n    },\n\n    // parse pattern definitions and precompute some values\n    _initPatterns: function _initPatterns(patternDefs) {\n        return patternDefs.map(this._parsePatternDef);\n    },\n\n    /**\n    * Changes the patterns used by this decorator\n    * and redraws the new one.\n    */\n    setPatterns: function setPatterns(patterns) {\n        this.options.patterns = patterns;\n        this._patterns = this._initPatterns(this.options.patterns);\n        this.redraw();\n    },\n\n    /**\n    * Changes the patterns used by this decorator\n    * and redraws the new one.\n    */\n    setPaths: function setPaths(paths) {\n        this._paths = this._initPaths(paths);\n        this._bounds = this._initBounds();\n        this.redraw();\n    },\n\n    /**\n    * Parse the pattern definition\n    */\n    _parsePatternDef: function _parsePatternDef(patternDef, latLngs) {\n        return {\n            symbolFactory: patternDef.symbol,\n            // Parse offset and repeat values, managing the two cases:\n            // absolute (in pixels) or relative (in percentage of the polyline length)\n            offset: parseRelativeOrAbsoluteValue(patternDef.offset),\n            endOffset: parseRelativeOrAbsoluteValue(patternDef.endOffset),\n            repeat: parseRelativeOrAbsoluteValue(patternDef.repeat)\n        };\n    },\n\n    onAdd: function onAdd(map) {\n        this._map = map;\n        this._draw();\n        this._map.on('moveend', this.redraw, this);\n    },\n\n    onRemove: function onRemove(map) {\n        this._map.off('moveend', this.redraw, this);\n        this._map = null;\n        L$1.FeatureGroup.prototype.onRemove.call(this, map);\n    },\n\n    /**\n    * As real pattern bounds depends on map zoom and bounds,\n    * we just compute the total bounds of all paths decorated by this instance.\n    */\n    _initBounds: function _initBounds() {\n        var allPathCoords = this._paths.reduce(function (acc, path) {\n            return acc.concat(path);\n        }, []);\n        return L$1.latLngBounds(allPathCoords);\n    },\n\n    getBounds: function getBounds() {\n        return this._bounds;\n    },\n\n    /**\n    * Returns an array of ILayers object\n    */\n    _buildSymbols: function _buildSymbols(latLngs, symbolFactory, directionPoints) {\n        var _this2 = this;\n\n        return directionPoints.map(function (directionPoint, i) {\n            return symbolFactory.buildSymbol(directionPoint, latLngs, _this2._map, i, directionPoints.length);\n        });\n    },\n\n    /**\n    * Compute pairs of LatLng and heading angle,\n    * that define positions and directions of the symbols on the path\n    */\n    _getDirectionPoints: function _getDirectionPoints(latLngs, pattern) {\n        var _this3 = this;\n\n        if (latLngs.length < 2) {\n            return [];\n        }\n        var pathAsPoints = latLngs.map(function (latLng) {\n            return _this3._map.project(latLng);\n        });\n        return projectPatternOnPointPath(pathAsPoints, pattern).map(function (point) {\n            return {\n                latLng: _this3._map.unproject(L$1.point(point.pt)),\n                heading: point.heading\n            };\n        });\n    },\n\n    redraw: function redraw() {\n        if (!this._map) {\n            return;\n        }\n        this.clearLayers();\n        this._draw();\n    },\n\n    /**\n    * Returns all symbols for a given pattern as an array of FeatureGroup\n    */\n    _getPatternLayers: function _getPatternLayers(pattern) {\n        var _this4 = this;\n\n        var mapBounds = this._map.getBounds().pad(0.1);\n        return this._paths.map(function (path) {\n            var directionPoints = _this4._getDirectionPoints(path, pattern)\n            // filter out invisible points\n            .filter(function (point) {\n                return mapBounds.contains(point.latLng);\n            });\n            return L$1.featureGroup(_this4._buildSymbols(path, pattern.symbolFactory, directionPoints));\n        });\n    },\n\n    /**\n    * Draw all patterns\n    */\n    _draw: function _draw() {\n        var _this5 = this;\n\n        this._patterns.map(function (pattern) {\n            return _this5._getPatternLayers(pattern);\n        }).forEach(function (layers) {\n            _this5.addLayer(L$1.featureGroup(layers));\n        });\n    }\n});\n/*\n * Allows compact syntax to be used\n */\nL$1.polylineDecorator = function (paths, options) {\n    return new L$1.PolylineDecorator(paths, options);\n};\n\n})));\n"],
  "mappings": ";;;;;;;;AAAA;AAAA;AAAA,KAAC,SAAU,QAAQ,SAAS;AAC3B,aAAO,YAAY,YAAY,OAAO,WAAW,cAAc,QAAQ,qBAAkB,IACzF,OAAO,WAAW,cAAc,OAAO,MAAM,OAAO,CAAC,SAAS,GAAG,OAAO,IACvE,QAAQ,OAAO,CAAC;AAAA,IAClB,GAAE,SAAO,SAAU,KAAK;AAAE;AAE1B,YAAM,OAAO,IAAI,eAAe,SAAS,IAAI,IAAI,SAAS,IAAI;AAI9D,eAAS,cAAc,KAAK,KAAK;AAC7B,YAAI,IAAI,IAAI,IAAI,IAAI;AACpB,YAAI,IAAI,IAAI,IAAI,IAAI;AACpB,eAAO,KAAK,KAAK,IAAI,IAAI,IAAI,CAAC;AAAA,MAClC;AAEA,UAAI,wBAAwB,SAASA,uBAAsB,GAAG,GAAG;AAC7D,gBAAQ,KAAK,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,IAAI,EAAE,CAAC,IAAI,MAAM,KAAK,KAAK,KAAK,OAAO;AAAA,MAC3E;AAEA,UAAI,sBAAsB,SAASC,qBAAoB,MAAM,iBAAiB;AAC1E,YAAI,QAAQ,KAAK,OACb,aAAa,KAAK;AACtB,eAAO,aAAa,QAAQ,kBAAkB;AAAA,MAClD;AAEA,eAAS,6BAA6B,OAAO;AACzC,YAAI,OAAO,UAAU,YAAY,MAAM,QAAQ,GAAG,MAAM,IAAI;AACxD,iBAAO;AAAA,YACH,OAAO,WAAW,KAAK,IAAI;AAAA,YAC3B,YAAY;AAAA,UAChB;AAAA,QACJ;AACA,YAAI,cAAc,QAAQ,WAAW,KAAK,IAAI;AAC9C,eAAO;AAAA,UACH,OAAO;AAAA,UACP,YAAY,cAAc;AAAA,QAC9B;AAAA,MACJ;AAEA,UAAI,cAAc,SAASC,aAAY,GAAG,GAAG;AACzC,eAAO,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE;AAAA,MACpC;AAEA,eAAS,iBAAiB,KAAK;AAC3B,eAAO,IAAI,OAAO,SAAU,UAAU,GAAG,KAAK,QAAQ;AAElD,cAAI,MAAM,KAAK,CAAC,YAAY,GAAG,OAAO,MAAM,CAAC,CAAC,GAAG;AAC7C,gBAAI,IAAI,OAAO,MAAM,CAAC;AACtB,gBAAI,QAAQ,SAAS,SAAS,IAAI,SAAS,SAAS,SAAS,CAAC,EAAE,QAAQ;AACxE,gBAAI,SAAS,cAAc,GAAG,CAAC;AAC/B,qBAAS,KAAK;AAAA,cACV;AAAA,cACA;AAAA,cACA;AAAA,cACA,OAAO,QAAQ;AAAA,cACf,SAAS,sBAAsB,GAAG,CAAC;AAAA,YACvC,CAAC;AAAA,UACL;AACA,iBAAO;AAAA,QACX,GAAG,CAAC,CAAC;AAAA,MACT;AAEA,eAAS,0BAA0B,KAAK,SAAS;AAE7C,YAAI,WAAW,iBAAiB,GAAG;AACnC,YAAI,aAAa,SAAS;AAC1B,YAAI,eAAe,GAAG;AAClB,iBAAO,CAAC;AAAA,QACZ;AAEA,YAAI,kBAAkB,SAAS,aAAa,CAAC,EAAE;AAE/C,YAAI,SAAS,oBAAoB,QAAQ,QAAQ,eAAe;AAChE,YAAI,YAAY,oBAAoB,QAAQ,WAAW,eAAe;AACtE,YAAI,SAAS,oBAAoB,QAAQ,QAAQ,eAAe;AAEhE,YAAI,uBAAuB,kBAAkB;AAC7C,YAAI,oBAAoB,SAAS,IAAI,kBAAkB,SAAS;AAChE,YAAI,kBAAkB,YAAY,IAAI,kBAAkB,YAAY;AAGpE,YAAI,kBAAkB,CAAC;AACvB,YAAI,iBAAiB;AACrB,WAAG;AACC,0BAAgB,KAAK,cAAc;AACnC,4BAAkB;AAAA,QACtB,SAAS,uBAAuB,KAAK,iBAAiB,kBAAkB;AAGxE,YAAI,eAAe;AACnB,YAAI,UAAU,SAAS,CAAC;AACxB,eAAO,gBAAgB,IAAI,SAAUC,iBAAgB;AAGjD,iBAAOA,kBAAiB,QAAQ,SAAS,eAAe,aAAa,GAAG;AACpE;AACA,sBAAU,SAAS,YAAY;AAAA,UACnC;AAEA,cAAI,gBAAgBA,kBAAiB,QAAQ,UAAU,QAAQ,QAAQ,QAAQ;AAC/E,iBAAO;AAAA,YACH,IAAI,yBAAyB,QAAQ,GAAG,QAAQ,GAAG,YAAY;AAAA,YAC/D,SAAS,QAAQ;AAAA,UACrB;AAAA,QACJ,CAAC;AAAA,MACL;AAMA,eAAS,yBAAyB,KAAK,KAAK,OAAO;AAC/C,YAAI,IAAI,MAAM,IAAI,GAAG;AACjB,iBAAO;AAAA,YACH,GAAG,IAAI,IAAI,SAAS,IAAI,IAAI,IAAI;AAAA,YAChC,GAAG,IAAI,IAAI,SAAS,IAAI,IAAI,IAAI;AAAA,UACpC;AAAA,QACJ;AAEA,eAAO;AAAA,UACH,GAAG,IAAI;AAAA,UACP,GAAG,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK;AAAA,QACjC;AAAA,MACJ;AAEA,OAAC,WAAW;AAER,YAAI,iBAAiB,EAAE,OAAO,UAAU;AACxC,YAAI,eAAe,EAAE,OAAO,UAAU;AAEtC,YAAI,QAAS,EAAE,QAAQ,cAAc;AAErC,UAAE,OAAO,YAAY,WAAY;AAC7B,cAAI,cAAc,KAAK,QAAQ,QAAQ,KAAK,QAAQ,KAAK;AACzD,cAAI,aAAa,eAAe,KAAK,QAAQ,KAAK,QAAQ;AAC1D,cAAI,YAAY;AACZ,yBAAc,WAAW,CAAC,IAAI,QAAQ,WAAW,CAAC,IAAI;AAAA,UAC1D;AACA,eAAK,QAAQ,iBAAiB,KAAK,QAAQ,kBAAkB,cAAc;AAC3E,eAAK,QAAQ,gBAAgB,KAAK,QAAQ,iBAAiB;AAG3D,eAAK,GAAG,QAAQ,SAAS,GAAG;AAAE,cAAE,OAAO,eAAe;AAAA,UAAG,CAAC;AAAA,QAC9D,CAAC;AAED,UAAE,OAAO,QAAQ;AAAA,UACb,WAAW,WAAW;AAClB,2BAAe,KAAK,IAAI;AAAA,UAC5B;AAAA,UAEA,SAAS,SAAU,KAAK;AACpB,yBAAa,KAAK,MAAM,GAAG;AAC3B,iBAAK,eAAe;AAAA,UACxB;AAAA,UAEA,gBAAgB,WAAY;AACxB,gBAAG,KAAK,QAAQ,eAAe;AAC3B,mBAAK,MAAM,MAAM,EAAE,QAAQ,YAAU,QAAQ,IAAI,KAAK,QAAQ;AAE9D,kBAAG,OAAO;AAEN,qBAAK,MAAM,MAAM,EAAE,QAAQ,SAAS,IAAI,YAAY,KAAK,QAAQ,gBAAgB;AAAA,cACrF,OAAO;AAEH,qBAAK,MAAM,MAAM,EAAE,QAAQ,SAAS,KAAK,cAAc,KAAK,QAAQ,gBAAgB;AAAA,cACxF;AAAA,YACJ;AAAA,UACJ;AAAA,UAEA,kBAAkB,SAAS,OAAO;AAC9B,iBAAK,QAAQ,gBAAgB;AAC7B,iBAAK,OAAO;AACZ,mBAAO;AAAA,UACX;AAAA,UAEA,mBAAmB,SAAS,QAAQ;AAChC,iBAAK,QAAQ,iBAAiB;AAC9B,iBAAK,OAAO;AACZ,mBAAO;AAAA,UACX;AAAA,QACJ,CAAC;AAAA,MACL,GAAG;AAEH,UAAI,SAAS,IAAI,UAAU,CAAC;AAM5B,UAAI,OAAO,OAAO,IAAI,MAAM,OAAO;AAAA,QAC/B,SAAS;AAAA,UACL,WAAW;AAAA,UACX,aAAa,CAAC;AAAA,QAClB;AAAA,QAEA,YAAY,SAAS,WAAW,SAAS;AACrC,cAAI,KAAK,WAAW,MAAM,OAAO;AACjC,eAAK,QAAQ,YAAY,YAAY;AAAA,QACzC;AAAA,QAEA,aAAa,SAAS,YAAY,UAAU,SAAS,KAAK,OAAO,OAAO;AACpE,cAAI,OAAO,KAAK;AAChB,cAAI,MAAM,KAAK,KAAK;AAGpB,cAAI,KAAK,aAAa,GAAG;AACrB,mBAAO,IAAI,SAAS,CAAC,SAAS,QAAQ,SAAS,MAAM,GAAG,KAAK,WAAW;AAAA,UAC5E;AAEA,cAAI,WAAW,IAAI,QAAQ,SAAS,MAAM;AAC1C,cAAI,QAAQ,EAAE,SAAS,UAAU,MAAM;AACvC,cAAI,IAAI,IAAI,MAAM,SAAS,IAAI,KAAK,YAAY,KAAK,IAAI,QAAQ,KAAK,EAAE,IAAI,GAAG,SAAS,IAAI,KAAK,YAAY,KAAK,IAAI,KAAK,IAAI,CAAC;AAEhI,cAAI,IAAI,SAAS,IAAI,SAAS,SAAS,CAAC,CAAC;AACzC,iBAAO,IAAI,SAAS,CAAC,IAAI,UAAU,CAAC,GAAG,IAAI,UAAU,CAAC,CAAC,GAAG,KAAK,WAAW;AAAA,QAC9E;AAAA,MACJ,CAAC;AAED,UAAI,OAAO,OAAO,SAAU,SAAS;AACjC,eAAO,IAAI,IAAI,OAAO,KAAK,OAAO;AAAA,MACtC;AAEA,UAAI,OAAO,YAAY,IAAI,MAAM,OAAO;AAAA,QACpC,SAAS;AAAA,UACL,SAAS;AAAA,UACT,WAAW;AAAA,UACX,WAAW;AAAA,UACX,aAAa;AAAA,YACT,QAAQ;AAAA,YACR,QAAQ;AAAA,UACZ;AAAA,QACJ;AAAA,QAEA,YAAY,SAAS,WAAW,SAAS;AACrC,cAAI,KAAK,WAAW,MAAM,OAAO;AACjC,eAAK,QAAQ,YAAY,YAAY;AAAA,QACzC;AAAA,QAEA,aAAa,SAAS,YAAY,UAAU,SAAS,KAAK,OAAO,OAAO;AACpE,iBAAO,KAAK,QAAQ,UAAU,IAAI,QAAQ,KAAK,gBAAgB,UAAU,GAAG,GAAG,KAAK,QAAQ,WAAW,IAAI,IAAI,SAAS,KAAK,gBAAgB,UAAU,GAAG,GAAG,KAAK,QAAQ,WAAW;AAAA,QACzL;AAAA,QAEA,iBAAiB,SAAS,gBAAgB,UAAU,KAAK;AACrD,cAAI,MAAM,KAAK,KAAK;AACpB,cAAI,WAAW,IAAI,QAAQ,SAAS,MAAM;AAC1C,cAAI,YAAY,EAAE,SAAS,UAAU,MAAM;AAC3C,cAAI,mBAAmB,KAAK,QAAQ,YAAY,IAAI;AAEpD,cAAI,aAAa,YAAY;AAC7B,cAAI,aAAa,YAAY;AAC7B,cAAI,aAAa,IAAI,MAAM,SAAS,IAAI,KAAK,QAAQ,YAAY,KAAK,IAAI,UAAU,GAAG,SAAS,IAAI,KAAK,QAAQ,YAAY,KAAK,IAAI,UAAU,CAAC;AACjJ,cAAI,aAAa,IAAI,MAAM,SAAS,IAAI,KAAK,QAAQ,YAAY,KAAK,IAAI,UAAU,GAAG,SAAS,IAAI,KAAK,QAAQ,YAAY,KAAK,IAAI,UAAU,CAAC;AAEjJ,iBAAO,CAAC,IAAI,UAAU,UAAU,GAAG,SAAS,QAAQ,IAAI,UAAU,UAAU,CAAC;AAAA,QACjF;AAAA,MACJ,CAAC;AAED,UAAI,OAAO,YAAY,SAAU,SAAS;AACtC,eAAO,IAAI,IAAI,OAAO,UAAU,OAAO;AAAA,MAC3C;AAEA,UAAI,OAAO,SAAS,IAAI,MAAM,OAAO;AAAA,QACjC,SAAS;AAAA,UACL,eAAe,CAAC;AAAA,UAChB,QAAQ;AAAA,QACZ;AAAA,QAEA,YAAY,SAAS,WAAW,SAAS;AACrC,cAAI,KAAK,WAAW,MAAM,OAAO;AACjC,eAAK,QAAQ,cAAc,YAAY;AACvC,eAAK,QAAQ,cAAc,YAAY;AAAA,QAC3C;AAAA,QAEA,aAAa,SAAS,YAAY,gBAAgB,SAAS,KAAK,OAAO,OAAO;AAC1E,cAAI,KAAK,QAAQ,QAAQ;AACrB,iBAAK,QAAQ,cAAc,gBAAgB,eAAe,WAAW,KAAK,QAAQ,mBAAmB;AAAA,UACzG;AACA,iBAAO,IAAI,OAAO,eAAe,QAAQ,KAAK,QAAQ,aAAa;AAAA,QACvE;AAAA,MACJ,CAAC;AAED,UAAI,OAAO,SAAS,SAAU,SAAS;AACnC,eAAO,IAAI,IAAI,OAAO,OAAO,OAAO;AAAA,MACxC;AAEA,UAAI,UAAU,SAASC,SAAQ,GAAG;AAC9B,eAAO,aAAa,IAAI,UAAU,MAAM,QAAQ,CAAC,KAAK,EAAE,WAAW,KAAK,OAAO,EAAE,CAAC,MAAM;AAAA,MAC5F;AAEA,UAAI,eAAe,SAASC,cAAa,IAAI;AACzC,eAAO,MAAM,QAAQ,EAAE,KAAK,QAAQ,GAAG,CAAC,CAAC;AAAA,MAC7C;AAEA,UAAI,oBAAoB,IAAI,aAAa,OAAO;AAAA,QAC5C,SAAS;AAAA,UACL,UAAU,CAAC;AAAA,QACf;AAAA,QAEA,YAAY,SAAS,WAAW,OAAO,SAAS;AAC5C,cAAI,aAAa,UAAU,WAAW,KAAK,IAAI;AAC/C,cAAI,KAAK,WAAW,MAAM,OAAO;AACjC,eAAK,OAAO;AACZ,eAAK,SAAS,KAAK,WAAW,KAAK;AACnC,eAAK,UAAU,KAAK,YAAY;AAChC,eAAK,YAAY,KAAK,cAAc,KAAK,QAAQ,QAAQ;AAAA,QAC7D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAOA,YAAY,SAAS,WAAW,OAAO,WAAW;AAC9C,cAAI,QAAQ;AAEZ,cAAI,aAAa,KAAK,GAAG;AAErB,gBAAI,SAAS,YAAY,MAAM,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI;AACpD,mBAAO,CAAC,MAAM;AAAA,UAClB;AACA,cAAI,iBAAiB,IAAI,UAAU;AAE/B,mBAAO,KAAK,WAAW,MAAM,WAAW,GAAG,iBAAiB,IAAI,OAAO;AAAA,UAC3E;AACA,cAAI,MAAM,QAAQ,KAAK,GAAG;AAEtB,mBAAO,MAAM,OAAO,SAAU,WAAW,GAAG;AACxC,qBAAO,UAAU,OAAO,MAAM,WAAW,GAAG,SAAS,CAAC;AAAA,YAC1D,GAAG,CAAC,CAAC;AAAA,UACT;AACA,iBAAO,CAAC;AAAA,QACZ;AAAA;AAAA,QAGA,eAAe,SAAS,cAAc,aAAa;AAC/C,iBAAO,YAAY,IAAI,KAAK,gBAAgB;AAAA,QAChD;AAAA;AAAA;AAAA;AAAA;AAAA,QAMA,aAAa,SAAS,YAAY,UAAU;AACxC,eAAK,QAAQ,WAAW;AACxB,eAAK,YAAY,KAAK,cAAc,KAAK,QAAQ,QAAQ;AACzD,eAAK,OAAO;AAAA,QAChB;AAAA;AAAA;AAAA;AAAA;AAAA,QAMA,UAAU,SAAS,SAAS,OAAO;AAC/B,eAAK,SAAS,KAAK,WAAW,KAAK;AACnC,eAAK,UAAU,KAAK,YAAY;AAChC,eAAK,OAAO;AAAA,QAChB;AAAA;AAAA;AAAA;AAAA,QAKA,kBAAkB,SAAS,iBAAiB,YAAY,SAAS;AAC7D,iBAAO;AAAA,YACH,eAAe,WAAW;AAAA;AAAA;AAAA,YAG1B,QAAQ,6BAA6B,WAAW,MAAM;AAAA,YACtD,WAAW,6BAA6B,WAAW,SAAS;AAAA,YAC5D,QAAQ,6BAA6B,WAAW,MAAM;AAAA,UAC1D;AAAA,QACJ;AAAA,QAEA,OAAO,SAAS,MAAM,KAAK;AACvB,eAAK,OAAO;AACZ,eAAK,MAAM;AACX,eAAK,KAAK,GAAG,WAAW,KAAK,QAAQ,IAAI;AAAA,QAC7C;AAAA,QAEA,UAAU,SAAS,SAAS,KAAK;AAC7B,eAAK,KAAK,IAAI,WAAW,KAAK,QAAQ,IAAI;AAC1C,eAAK,OAAO;AACZ,cAAI,aAAa,UAAU,SAAS,KAAK,MAAM,GAAG;AAAA,QACtD;AAAA;AAAA;AAAA;AAAA;AAAA,QAMA,aAAa,SAAS,cAAc;AAChC,cAAI,gBAAgB,KAAK,OAAO,OAAO,SAAU,KAAK,MAAM;AACxD,mBAAO,IAAI,OAAO,IAAI;AAAA,UAC1B,GAAG,CAAC,CAAC;AACL,iBAAO,IAAI,aAAa,aAAa;AAAA,QACzC;AAAA,QAEA,WAAW,SAAS,YAAY;AAC5B,iBAAO,KAAK;AAAA,QAChB;AAAA;AAAA;AAAA;AAAA,QAKA,eAAe,SAAS,cAAc,SAAS,eAAe,iBAAiB;AAC3E,cAAI,SAAS;AAEb,iBAAO,gBAAgB,IAAI,SAAU,gBAAgB,GAAG;AACpD,mBAAO,cAAc,YAAY,gBAAgB,SAAS,OAAO,MAAM,GAAG,gBAAgB,MAAM;AAAA,UACpG,CAAC;AAAA,QACL;AAAA;AAAA;AAAA;AAAA;AAAA,QAMA,qBAAqB,SAAS,oBAAoB,SAAS,SAAS;AAChE,cAAI,SAAS;AAEb,cAAI,QAAQ,SAAS,GAAG;AACpB,mBAAO,CAAC;AAAA,UACZ;AACA,cAAI,eAAe,QAAQ,IAAI,SAAU,QAAQ;AAC7C,mBAAO,OAAO,KAAK,QAAQ,MAAM;AAAA,UACrC,CAAC;AACD,iBAAO,0BAA0B,cAAc,OAAO,EAAE,IAAI,SAAU,OAAO;AACzE,mBAAO;AAAA,cACH,QAAQ,OAAO,KAAK,UAAU,IAAI,MAAM,MAAM,EAAE,CAAC;AAAA,cACjD,SAAS,MAAM;AAAA,YACnB;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,QAEA,QAAQ,SAAS,SAAS;AACtB,cAAI,CAAC,KAAK,MAAM;AACZ;AAAA,UACJ;AACA,eAAK,YAAY;AACjB,eAAK,MAAM;AAAA,QACf;AAAA;AAAA;AAAA;AAAA,QAKA,mBAAmB,SAAS,kBAAkB,SAAS;AACnD,cAAI,SAAS;AAEb,cAAI,YAAY,KAAK,KAAK,UAAU,EAAE,IAAI,GAAG;AAC7C,iBAAO,KAAK,OAAO,IAAI,SAAU,MAAM;AACnC,gBAAI,kBAAkB,OAAO,oBAAoB,MAAM,OAAO,EAE7D,OAAO,SAAU,OAAO;AACrB,qBAAO,UAAU,SAAS,MAAM,MAAM;AAAA,YAC1C,CAAC;AACD,mBAAO,IAAI,aAAa,OAAO,cAAc,MAAM,QAAQ,eAAe,eAAe,CAAC;AAAA,UAC9F,CAAC;AAAA,QACL;AAAA;AAAA;AAAA;AAAA,QAKA,OAAO,SAAS,QAAQ;AACpB,cAAI,SAAS;AAEb,eAAK,UAAU,IAAI,SAAU,SAAS;AAClC,mBAAO,OAAO,kBAAkB,OAAO;AAAA,UAC3C,CAAC,EAAE,QAAQ,SAAU,QAAQ;AACzB,mBAAO,SAAS,IAAI,aAAa,MAAM,CAAC;AAAA,UAC5C,CAAC;AAAA,QACL;AAAA,MACJ,CAAC;AAID,UAAI,oBAAoB,SAAU,OAAO,SAAS;AAC9C,eAAO,IAAI,IAAI,kBAAkB,OAAO,OAAO;AAAA,MACnD;AAAA,IAEA,CAAE;AAAA;AAAA;",
  "names": ["computeSegmentHeading", "asRatioToPathLength", "pointsEqual", "positionOffset", "isCoord", "isCoordArray"]
}
